# ë„¤ì´ë²„ API í†µí•© ê°€ì´ë“œ

## ğŸ“‹ ëª©ì°¨
1. [ë„¤ì´ë²„ í´ë¼ìš°ë“œ vs ë„¤ì´ë²„ ì˜¤í”ˆ API](#1-ë„¤ì´ë²„-í´ë¼ìš°ë“œ-vs-ë„¤ì´ë²„-ì˜¤í”ˆ-api)
2. [ShipShare í”„ë¡œì íŠ¸ ì¶”ì²œ API](#2-shipshare-í”„ë¡œì íŠ¸-ì¶”ì²œ-api)
3. [ë„¤ì´ë²„ í´ë¼ìš°ë“œ API](#3-ë„¤ì´ë²„-í´ë¼ìš°ë“œ-api)
4. [ë„¤ì´ë²„ ì˜¤í”ˆ API](#4-ë„¤ì´ë²„-ì˜¤í”ˆ-api)
5. [í†µí•© êµ¬í˜„ ì˜ˆì‹œ](#5-í†µí•©-êµ¬í˜„-ì˜ˆì‹œ)
6. [ì „ì²´ í†µí•© ë¡œë“œë§µ](#6-ì „ì²´-í†µí•©-ë¡œë“œë§µ)

---

## 1. ë„¤ì´ë²„ í´ë¼ìš°ë“œ vs ë„¤ì´ë²„ ì˜¤í”ˆ API

### ğŸ”µ **ë„¤ì´ë²„ í´ë¼ìš°ë“œ Platform** (ìœ ë£Œ)
- URL: https://console.ncloud.com
- ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ì¸í”„ë¼ ì„œë¹„ìŠ¤
- ì‹ ìš©ì¹´ë“œ ë“±ë¡ í•„ìš”
- ì¢…ëŸ‰ì œ ê³¼ê¸ˆ

### ğŸŸ¢ **ë„¤ì´ë²„ ì˜¤í”ˆ API** (ë¬´ë£Œ/ì œí•œì )
- URL: https://developers.naver.com
- ê°œë°œììš© ê³µê°œ API
- ë¬´ë£Œ (ì¼ì¼ í˜¸ì¶œ ì œí•œ)
- ì• í”Œë¦¬ì¼€ì´ì…˜ ë“±ë¡ í•„ìš”

---

## 2. ShipShare í”„ë¡œì íŠ¸ ì¶”ì²œ API

### ğŸŒŸ **ìµœìš°ì„  í†µí•© (ë¬´ë£Œ/ì €ë¹„ìš©)**

#### âœ… 1. **ë„¤ì´ë²„ ì§€ë„ API** (ë¬´ë£Œ)
**ìš©ë„**: í•­êµ¬ ìœ„ì¹˜, ë°°ì†¡ ê²½ë¡œ ì‹œê°í™”
```
ì¼ì¼ í˜¸ì¶œ: ë¬´ë£Œ 50,000íšŒ
ì´ˆê³¼ ì‹œ: ê±´ë‹¹ â‚©0.5
```

#### âœ… 2. **íŒŒíŒŒê³  ë²ˆì—­ API** (ë¬´ë£Œ)
**ìš©ë„**: ë‹¤êµ­ì–´ ì§€ì› (í•œ/ì˜/ì¤‘/ì¼)
```
ì¼ì¼ í˜¸ì¶œ: ë¬´ë£Œ 10,000ì
ì´ˆê³¼ ì‹œ: 10,000ìë‹¹ â‚©20
```

#### âœ… 3. **ë„¤ì´ë²„ ê²€ìƒ‰ API** (ë¬´ë£Œ)
**ìš©ë„**: ì„ ì‚¬ ì •ë³´, í•­êµ¬ ì •ë³´ ê²€ìƒ‰
```
ì¼ì¼ í˜¸ì¶œ: ë¬´ë£Œ 25,000íšŒ
```

#### âœ… 4. **ë„¤ì´ë²„ í´ë¼ìš°ë“œ SENS** (ìœ ë£Œ, ì´ë¯¸ ì¤€ë¹„ë¨)
**ìš©ë„**: ë§¤ì§ ë§í¬ ì´ë©”ì¼, SMS ì¸ì¦
```
ì´ë©”ì¼: 500ê±´ ë¬´ë£Œ, ì´ˆê³¼ ì‹œ ê±´ë‹¹ â‚©4
SMS: ê±´ë‹¹ â‚©9
```

#### âœ… 5. **CLOVA OCR** (ìœ ë£Œ)
**ìš©ë„**: ì„ í•˜ì¦ê¶Œ, ê³µë™ì¸ì¦ì„œ ìë™ ì¸ì‹
```
ì›” 1,000ê±´ ë¬´ë£Œ
ì´ˆê³¼ ì‹œ: ê±´ë‹¹ â‚©30
```

---

### ğŸ¯ **ì¶”ê°€ ê³ ë ¤ API**

#### ğŸ”¶ 6. **ë„¤ì´ë²„ í´ë¼ìš°ë“œ Maps** (ìœ ë£Œ)
**ìš©ë„**: ê³ ê¸‰ ì§€ë„ ê¸°ëŠ¥ (ê²½ë¡œ ìµœì í™”)
```
ì›” 100,000ê±´: â‚©30,000
```

#### ğŸ”¶ 7. **CLOVA Chatbot** (ìœ ë£Œ)
**ìš©ë„**: ê³ ê° ë¬¸ì˜ ìë™ ì‘ë‹µ
```
ì›” 1,000ê±´: ë¬´ë£Œ
ì´ˆê³¼ ì‹œ: ê±´ë‹¹ â‚©30
```

#### ğŸ”¶ 8. **CLOVA Speech** (TTS/STT) (ìœ ë£Œ)
**ìš©ë„**: ìŒì„± ì•ˆë‚´, ìŒì„± ê²€ìƒ‰
```
ì›” 30ë¶„: ë¬´ë£Œ
ì´ˆê³¼ ì‹œ: ë¶„ë‹¹ â‚©30
```

---

## 3. ë„¤ì´ë²„ í´ë¼ìš°ë“œ API

### ğŸ”µ **SENS (ì´ë¯¸ êµ¬í˜„ ì™„ë£Œ)**

**íŒŒì¼**: `src/lib/ncloud-sens.ts`

**ê¸°ëŠ¥**:
- âœ… ì´ë©”ì¼ ë°œì†¡ (ë§¤ì§ ë§í¬)
- âœ… SMS ì¸ì¦
- âœ… ì•Œë¦¼í†¡ (ì¹´ì¹´ì˜¤í†¡)

**ì‚¬ìš© ì˜ˆì‹œ**:
```typescript
import { createSENSClient } from '../lib/ncloud-sens'

const sens = createSENSClient(c.env)
await sens.sendMagicLinkEmail(email, magicCode)
```

---

### ğŸ”µ **CLOVA OCR**

**ìš©ë„**: ì„ í•˜ì¦ê¶Œ, ê³µë™ì¸ì¦ì„œ, ì—¬ê¶Œ ìŠ¤ìº”

**êµ¬í˜„**:
```typescript
// src/lib/ncloud-ocr.ts
import crypto from 'crypto'

export class NCloudOCR {
  private invokeUrl: string
  private secretKey: string

  constructor(invokeUrl: string, secretKey: string) {
    this.invokeUrl = invokeUrl
    this.secretKey = secretKey
  }

  /**
   * ë¬¸ì„œ OCR ì²˜ë¦¬
   */
  async recognizeDocument(imageBase64: string, format: string = 'jpg') {
    const requestBody = {
      version: 'V2',
      requestId: crypto.randomUUID(),
      timestamp: Date.now(),
      images: [
        {
          format: format,
          name: 'document',
          data: imageBase64,
        },
      ],
    }

    const response = await fetch(this.invokeUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-OCR-SECRET': this.secretKey,
      },
      body: JSON.stringify(requestBody),
    })

    if (!response.ok) {
      throw new Error(`CLOVA OCR Error: ${response.statusText}`)
    }

    const result = await response.json()
    
    return {
      fullText: result.images[0].fields.map((f: any) => f.inferText).join(' '),
      fields: result.images[0].fields,
    }
  }

  /**
   * ì„ í•˜ì¦ê¶Œ(B/L) ì •ë³´ ì¶”ì¶œ
   */
  async extractBillOfLading(imageBase64: string) {
    const result = await this.recognizeDocument(imageBase64)
    
    return {
      bookingNumber: this.extractPattern(result.fullText, /B\/L\s*NO[:\s]+(\w+)/i),
      vesselName: this.extractPattern(result.fullText, /VESSEL[:\s]+([A-Z\s]+)/i),
      voyageNumber: this.extractPattern(result.fullText, /VOYAGE[:\s]+(\w+)/i),
      portOfLoading: this.extractPattern(result.fullText, /PORT\s+OF\s+LOADING[:\s]+([A-Z\s]+)/i),
      portOfDischarge: this.extractPattern(result.fullText, /PORT\s+OF\s+DISCHARGE[:\s]+([A-Z\s]+)/i),
      containerNumber: this.extractPattern(result.fullText, /CONTAINER[:\s]+([A-Z0-9]{11})/i),
      rawText: result.fullText,
    }
  }

  private extractPattern(text: string, pattern: RegExp): string | null {
    const match = text.match(pattern)
    return match ? match[1].trim() : null
  }
}

export function createOCRClient(env: any): NCloudOCR {
  return new NCloudOCR(
    env.NCLOUD_CLOVA_OCR_URL,
    env.NCLOUD_CLOVA_OCR_SECRET
  )
}
```

---

### ğŸ”µ **Object Storage** (ì´ë¯¸ êµ¬í˜„ ì™„ë£Œ)

**íŒŒì¼**: `src/lib/ncloud-storage.ts` (NCLOUD_INTEGRATION_GUIDE.md ì°¸ê³ )

**ìš©ë„**: ì¸ì¦ì„œ íŒŒì¼, ì„ í•˜ì¦ê¶Œ ì´ë¯¸ì§€ ì €ì¥

---

## 4. ë„¤ì´ë²„ ì˜¤í”ˆ API

### ğŸŸ¢ **ë„¤ì´ë²„ ì§€ë„ API** (ìµœìš°ì„  ì¶”ì²œ)

**ìš©ë„**: í•­êµ¬ ìœ„ì¹˜ ì‹œê°í™”, ë°°ì†¡ ê²½ë¡œ í‘œì‹œ

**êµ¬í˜„**:
```typescript
// src/lib/naver-maps.ts
export class NaverMapsAPI {
  private clientId: string
  private clientSecret: string

  constructor(clientId: string, clientSecret: string) {
    this.clientId = clientId
    this.clientSecret = clientSecret
  }

  /**
   * ì£¼ì†Œ â†’ ì¢Œí‘œ ë³€í™˜ (Geocoding)
   */
  async geocode(address: string) {
    const url = `https://naveropenapi.apigw.ntruss.com/map-geocode/v2/geocode?query=${encodeURIComponent(address)}`

    const response = await fetch(url, {
      headers: {
        'X-NCP-APIGW-API-KEY-ID': this.clientId,
        'X-NCP-APIGW-API-KEY': this.clientSecret,
      },
    })

    if (!response.ok) {
      throw new Error(`Naver Maps API Error: ${response.statusText}`)
    }

    const data = await response.json()
    
    if (data.addresses && data.addresses.length > 0) {
      const addr = data.addresses[0]
      return {
        latitude: parseFloat(addr.y),
        longitude: parseFloat(addr.x),
        roadAddress: addr.roadAddress,
        jibunAddress: addr.jibunAddress,
      }
    }
    
    return null
  }

  /**
   * ì¢Œí‘œ â†’ ì£¼ì†Œ ë³€í™˜ (Reverse Geocoding)
   */
  async reverseGeocode(lat: number, lon: number) {
    const url = `https://naveropenapi.apigw.ntruss.com/map-reversegeocode/v2/gc?coords=${lon},${lat}&output=json`

    const response = await fetch(url, {
      headers: {
        'X-NCP-APIGW-API-KEY-ID': this.clientId,
        'X-NCP-APIGW-API-KEY': this.clientSecret,
      },
    })

    if (!response.ok) {
      throw new Error(`Naver Maps API Error: ${response.statusText}`)
    }

    const data = await response.json()
    
    if (data.results && data.results.length > 0) {
      const region = data.results[0].region
      return {
        address: `${region.area1.name} ${region.area2.name} ${region.area3.name}`,
        country: region.area0.name,
        province: region.area1.name,
        city: region.area2.name,
        district: region.area3.name,
      }
    }
    
    return null
  }

  /**
   * ë‘ ì§€ì  ê°„ ê±°ë¦¬ ê³„ì‚° (Haversine)
   */
  calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R = 6371 // ì§€êµ¬ ë°˜ì§€ë¦„ (km)
    const dLat = this.toRad(lat2 - lat1)
    const dLon = this.toRad(lon2 - lon1)
    
    const a = 
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2)
    
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
    return R * c
  }

  private toRad(deg: number): number {
    return deg * (Math.PI / 180)
  }
}

export function createNaverMapsClient(env: any): NaverMapsAPI {
  return new NaverMapsAPI(
    env.NAVER_MAP_CLIENT_ID,
    env.NAVER_MAP_CLIENT_SECRET
  )
}

/**
 * ì£¼ìš” í•­êµ¬ ì¢Œí‘œ
 */
export const PORT_COORDINATES = {
  BUSAN: { lat: 35.1028, lon: 129.0403 },
  INCHEON: { lat: 37.4563, lon: 126.7052 },
  GWANGYANG: { lat: 34.9406, lon: 127.6950 },
  ULSAN: { lat: 35.5384, lon: 129.3114 },
  SHANGHAI: { lat: 31.2304, lon: 121.4737 },
  LOS_ANGELES: { lat: 33.7405, lon: -118.2716 },
  SINGAPORE: { lat: 1.2644, lon: 103.8223 },
  ROTTERDAM: { lat: 51.9225, lon: 4.4792 },
} as const
```

---

### ğŸŸ¢ **íŒŒíŒŒê³  ë²ˆì—­ API**

**ìš©ë„**: ë‹¤êµ­ì–´ ì§€ì› (í•œêµ­ì–´ â†” ì˜ì–´/ì¤‘êµ­ì–´/ì¼ë³¸ì–´)

**êµ¬í˜„**:
```typescript
// src/lib/naver-papago.ts
export class NaverPapagoAPI {
  private clientId: string
  private clientSecret: string

  constructor(clientId: string, clientSecret: string) {
    this.clientId = clientId
    this.clientSecret = clientSecret
  }

  /**
   * í…ìŠ¤íŠ¸ ë²ˆì—­
   */
  async translate(text: string, sourceLang: string, targetLang: string) {
    const url = 'https://naveropenapi.apigw.ntruss.com/nmt/v1/translation'

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'X-NCP-APIGW-API-KEY-ID': this.clientId,
        'X-NCP-APIGW-API-KEY': this.clientSecret,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        source: sourceLang,
        target: targetLang,
        text: text,
      }),
    })

    if (!response.ok) {
      throw new Error(`Papago API Error: ${response.statusText}`)
    }

    const data = await response.json()
    return {
      translatedText: data.message.result.translatedText,
      sourceLang: sourceLang,
      targetLang: targetLang,
    }
  }

  /**
   * ì–¸ì–´ ê°ì§€
   */
  async detectLanguage(text: string) {
    const url = 'https://naveropenapi.apigw.ntruss.com/langs/v1/dect'

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'X-NCP-APIGW-API-KEY-ID': this.clientId,
        'X-NCP-APIGW-API-KEY': this.clientSecret,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        query: text,
      }),
    })

    if (!response.ok) {
      throw new Error(`Papago API Error: ${response.statusText}`)
    }

    const data = await response.json()
    return data.langCode
  }

  /**
   * ë‹¤êµ­ì–´ ìë™ ë²ˆì—­ (ì–¸ì–´ ìë™ ê°ì§€)
   */
  async autoTranslate(text: string, targetLang: string = 'en') {
    const sourceLang = await this.detectLanguage(text)
    
    if (sourceLang === targetLang) {
      return { translatedText: text, sourceLang, targetLang }
    }
    
    return await this.translate(text, sourceLang, targetLang)
  }
}

export function createPapagoClient(env: any): NaverPapagoAPI {
  return new NaverPapagoAPI(
    env.NAVER_PAPAGO_CLIENT_ID,
    env.NAVER_PAPAGO_CLIENT_SECRET
  )
}

/**
 * ì§€ì› ì–¸ì–´ ì½”ë“œ
 */
export const SUPPORTED_LANGUAGES = {
  KO: 'ko', // í•œêµ­ì–´
  EN: 'en', // ì˜ì–´
  JA: 'ja', // ì¼ë³¸ì–´
  ZH_CN: 'zh-CN', // ì¤‘êµ­ì–´ ê°„ì²´
  ZH_TW: 'zh-TW', // ì¤‘êµ­ì–´ ë²ˆì²´
  ES: 'es', // ìŠ¤í˜ì¸ì–´
  FR: 'fr', // í”„ë‘ìŠ¤ì–´
  DE: 'de', // ë…ì¼ì–´
  RU: 'ru', // ëŸ¬ì‹œì•„ì–´
  PT: 'pt', // í¬ë¥´íˆ¬ê°ˆì–´
  IT: 'it', // ì´íƒˆë¦¬ì•„ì–´
  VI: 'vi', // ë² íŠ¸ë‚¨ì–´
  TH: 'th', // íƒœêµ­ì–´
  ID: 'id', // ì¸ë„ë„¤ì‹œì•„ì–´
  HI: 'hi', // íŒë””ì–´
  AR: 'ar', // ì•„ëì–´
} as const
```

---

### ğŸŸ¢ **ë„¤ì´ë²„ ê²€ìƒ‰ API**

**ìš©ë„**: ì„ ì‚¬ ì •ë³´, í•­êµ¬ ì •ë³´, ë‰´ìŠ¤ ê²€ìƒ‰

**êµ¬í˜„**:
```typescript
// src/lib/naver-search.ts
export class NaverSearchAPI {
  private clientId: string
  private clientSecret: string

  constructor(clientId: string, clientSecret: string) {
    this.clientId = clientId
    this.clientSecret = clientSecret
  }

  /**
   * ë¸”ë¡œê·¸ ê²€ìƒ‰
   */
  async searchBlog(query: string, display: number = 10) {
    return await this.search('blog', query, display)
  }

  /**
   * ë‰´ìŠ¤ ê²€ìƒ‰
   */
  async searchNews(query: string, display: number = 10) {
    return await this.search('news', query, display)
  }

  /**
   * ì›¹ ë¬¸ì„œ ê²€ìƒ‰
   */
  async searchWeb(query: string, display: number = 10) {
    return await this.search('webkr', query, display)
  }

  /**
   * ì´ë¯¸ì§€ ê²€ìƒ‰
   */
  async searchImage(query: string, display: number = 10) {
    return await this.search('image', query, display)
  }

  /**
   * ê³µí†µ ê²€ìƒ‰ ë©”ì„œë“œ
   */
  private async search(type: string, query: string, display: number) {
    const url = `https://openapi.naver.com/v1/search/${type}?query=${encodeURIComponent(query)}&display=${display}`

    const response = await fetch(url, {
      headers: {
        'X-Naver-Client-Id': this.clientId,
        'X-Naver-Client-Secret': this.clientSecret,
      },
    })

    if (!response.ok) {
      throw new Error(`Naver Search API Error: ${response.statusText}`)
    }

    return await response.json()
  }
}

export function createNaverSearchClient(env: any): NaverSearchAPI {
  return new NaverSearchAPI(
    env.NAVER_SEARCH_CLIENT_ID,
    env.NAVER_SEARCH_CLIENT_SECRET
  )
}
```

---

## 5. í†µí•© êµ¬í˜„ ì˜ˆì‹œ

### ğŸ“ **ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ 1: ì„ ë°• ìœ„ì¹˜ + ì§€ë„**

```typescript
// src/routes/vessels.ts
import { createMarineTrafficClient } from '../lib/marine-traffic'
import { createNaverMapsClient, PORT_COORDINATES } from '../lib/naver-maps'

vessels.get('/:id/map-location', async (c) => {
  try {
    const vesselId = c.req.param('id')
    
    // 1. ì„ ë°• ìœ„ì¹˜ ì¡°íšŒ (MarineTraffic)
    const vessel = await c.env.DB.prepare(
      'SELECT mmsi, vessel_name FROM vessels WHERE id = ?'
    ).bind(vesselId).first()
    
    const marinTraffic = createMarineTrafficClient(c.env)
    const position = await marinTraffic.getVesselPosition(vessel.mmsi)
    
    // 2. ì¢Œí‘œ â†’ ì£¼ì†Œ ë³€í™˜ (ë„¤ì´ë²„ ì§€ë„)
    const naverMaps = createNaverMapsClient(c.env)
    const address = await naverMaps.reverseGeocode(
      position[0].LAT,
      position[0].LON
    )
    
    // 3. ê°€ì¥ ê°€ê¹Œìš´ í•­êµ¬ ì°¾ê¸°
    let nearestPort = null
    let minDistance = Infinity
    
    for (const [portName, coords] of Object.entries(PORT_COORDINATES)) {
      const distance = naverMaps.calculateDistance(
        position[0].LAT,
        position[0].LON,
        coords.lat,
        coords.lon
      )
      
      if (distance < minDistance) {
        minDistance = distance
        nearestPort = { name: portName, ...coords, distance }
      }
    }
    
    return c.json({
      success: true,
      vessel: {
        name: vessel.vessel_name,
        position: {
          lat: position[0].LAT,
          lon: position[0].LON,
          speed: position[0].SPEED,
          heading: position[0].HEADING,
        },
        location: address,
        nearestPort: nearestPort,
      }
    })
    
  } catch (error) {
    console.error('Get vessel map location error:', error)
    return c.json({ error: 'ìœ„ì¹˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' }, 500)
  }
})
```

---

### ğŸ“„ **ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ 2: ì„ í•˜ì¦ê¶Œ OCR**

```typescript
// src/routes/ocr.ts
import { Hono } from 'hono'
import { createOCRClient } from '../lib/ncloud-ocr'

const ocr = new Hono()

ocr.post('/bill-of-lading', async (c) => {
  try {
    const { imageBase64 } = await c.req.json()
    
    // CLOVA OCRë¡œ ì„ í•˜ì¦ê¶Œ ì¸ì‹
    const ocrClient = createOCRClient(c.env)
    const result = await ocrClient.extractBillOfLading(imageBase64)
    
    // ì¶”ì¶œëœ ì •ë³´ë¡œ ìë™ ì˜ˆì•½ ìƒì„± ê°€ëŠ¥
    if (result.bookingNumber && result.vesselName) {
      // DBì—ì„œ í•´ë‹¹ ì„ ë°• ì°¾ê¸°
      const vessel = await c.env.DB.prepare(
        'SELECT * FROM vessels WHERE vessel_name LIKE ?'
      ).bind(`%${result.vesselName}%`).first()
      
      if (vessel) {
        return c.json({
          success: true,
          extracted: result,
          vessel: vessel,
          message: 'ì„ í•˜ì¦ê¶Œ ì •ë³´ë¥¼ ì¸ì‹í–ˆìŠµë‹ˆë‹¤. ì˜ˆì•½ì„ ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?'
        })
      }
    }
    
    return c.json({
      success: true,
      extracted: result,
      message: 'ì„ í•˜ì¦ê¶Œ ì •ë³´ë¥¼ ì¸ì‹í–ˆìŠµë‹ˆë‹¤.'
    })
    
  } catch (error) {
    console.error('OCR error:', error)
    return c.json({ error: 'OCR ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' }, 500)
  }
})

export default ocr
```

---

### ğŸŒ **ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ 3: ë‹¤êµ­ì–´ ì§€ì›**

```typescript
// src/routes/translate.ts
import { Hono } from 'hono'
import { createPapagoClient } from '../lib/naver-papago'

const translate = new Hono()

// ì„ ë°• ì •ë³´ ìë™ ë²ˆì—­
translate.post('/vessel-info', async (c) => {
  try {
    const { vesselId, targetLang } = await c.req.json()
    
    // ì„ ë°• ì •ë³´ ì¡°íšŒ
    const vessel = await c.env.DB.prepare(
      'SELECT * FROM vessels WHERE id = ?'
    ).bind(vesselId).first()
    
    // íŒŒíŒŒê³ ë¡œ ë²ˆì—­
    const papago = createPapagoClient(c.env)
    
    const translatedName = await papago.autoTranslate(
      vessel.vessel_name,
      targetLang
    )
    
    const translatedDescription = vessel.description
      ? await papago.autoTranslate(vessel.description, targetLang)
      : null
    
    return c.json({
      success: true,
      original: {
        name: vessel.vessel_name,
        description: vessel.description,
      },
      translated: {
        name: translatedName.translatedText,
        description: translatedDescription?.translatedText,
        lang: targetLang,
      }
    })
    
  } catch (error) {
    console.error('Translation error:', error)
    return c.json({ error: 'ë²ˆì—­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' }, 500)
  }
})

// í˜ì´ì§€ ì „ì²´ ë²ˆì—­
translate.post('/page', async (c) => {
  try {
    const { texts, targetLang } = await c.req.json()
    
    const papago = createPapagoClient(c.env)
    
    const translations = await Promise.all(
      texts.map(async (text: string) => {
        const result = await papago.autoTranslate(text, targetLang)
        return result.translatedText
      })
    )
    
    return c.json({
      success: true,
      translations: translations,
      targetLang: targetLang
    })
    
  } catch (error) {
    console.error('Translation error:', error)
    return c.json({ error: 'ë²ˆì—­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' }, 500)
  }
})

export default translate
```

---

## 6. ì „ì²´ í†µí•© ë¡œë“œë§µ

### ğŸ¯ **Phase 1: í•„ìˆ˜ API (ë¬´ë£Œ)** - ì¦‰ì‹œ ì‹œì‘

```
1. âœ… ë„¤ì´ë²„ ì§€ë„ API
   - í•­êµ¬ ìœ„ì¹˜ í‘œì‹œ
   - ë°°ì†¡ ê²½ë¡œ ì‹œê°í™”
   - ê±°ë¦¬ ê³„ì‚°

2. âœ… íŒŒíŒŒê³  ë²ˆì—­ API
   - í•œ/ì˜/ì¤‘/ì¼ ë‹¤êµ­ì–´ ì§€ì›
   - ìë™ ì–¸ì–´ ê°ì§€
   
3. âœ… ë„¤ì´ë²„ ê²€ìƒ‰ API
   - ì„ ì‚¬ ì •ë³´ ê²€ìƒ‰
   - í•­êµ¬ ë‰´ìŠ¤
   
ë¹„ìš©: ë¬´ë£Œ (ì¼ì¼ ì œí•œ ë‚´)
```

---

### ğŸ¯ **Phase 2: í™•ì¥ API (ì €ë¹„ìš©)** - ë² íƒ€ ì¶œì‹œ

```
4. âœ… SENS ì´ë©”ì¼ (ì´ë¯¸ ì¤€ë¹„ë¨)
   - ë§¤ì§ ë§í¬ ë°œì†¡
   - ì˜ˆì•½ í™•ì¸ ì´ë©”ì¼
   
5. âœ… CLOVA OCR
   - ì„ í•˜ì¦ê¶Œ ìŠ¤ìº”
   - ê³µë™ì¸ì¦ì„œ ì¸ì‹
   
ë¹„ìš©: ~â‚©50,000/ì›”
```

---

### ğŸ¯ **Phase 3: ê³ ê¸‰ API (ì„ íƒ)** - ì •ì‹ ì¶œì‹œ

```
6. ğŸ”¶ ë„¤ì´ë²„ í´ë¼ìš°ë“œ Maps
   - ê²½ë¡œ ìµœì í™”
   - ì‹¤ì‹œê°„ êµí†µ ì •ë³´
   
7. ğŸ”¶ CLOVA Chatbot
   - ê³ ê° ë¬¸ì˜ ìë™ ì‘ë‹µ
   
8. ğŸ”¶ CLOVA Speech (TTS/STT)
   - ìŒì„± ì•ˆë‚´
   
ë¹„ìš©: ~â‚©100,000/ì›”
```

---

## ğŸ’° ë¹„ìš© ì‹œë®¬ë ˆì´ì…˜

### ì›” ì‚¬ìš©ì 1,000ëª… ê¸°ì¤€

| API | ì˜ˆìƒ í˜¸ì¶œ | ë¬´ë£Œ í•œë„ | ì´ˆê³¼ ë¹„ìš© | ì›” ë¹„ìš© |
|-----|----------|----------|----------|---------|
| **ë„¤ì´ë²„ ì§€ë„** | 30,000 | 50,000 | - | **ë¬´ë£Œ** |
| **íŒŒíŒŒê³ ** | 50,000ì | 300,000ì | - | **ë¬´ë£Œ** |
| **ê²€ìƒ‰ API** | 5,000 | 25,000 | - | **ë¬´ë£Œ** |
| **SENS ì´ë©”ì¼** | 1,000 | 500 | 500ê±´ Ã— â‚©4 | **â‚©2,000** |
| **CLOVA OCR** | 500 | 1,000 | - | **ë¬´ë£Œ** |
| **ì´ ë¹„ìš©** | - | - | - | **â‚©2,000** |

**ê²°ë¡ **: ê±°ì˜ ë¬´ë£Œë¡œ ê°•ë ¥í•œ ê¸°ëŠ¥ êµ¬í˜„ ê°€ëŠ¥! ğŸ‰

---

## ğŸ“š í™˜ê²½ ë³€ìˆ˜ ì„¤ì •

```bash
# .dev.vars

# ë„¤ì´ë²„ ì˜¤í”ˆ API (ë¬´ë£Œ)
NAVER_MAP_CLIENT_ID=your_map_client_id
NAVER_MAP_CLIENT_SECRET=your_map_client_secret
NAVER_PAPAGO_CLIENT_ID=your_papago_client_id
NAVER_PAPAGO_CLIENT_SECRET=your_papago_client_secret
NAVER_SEARCH_CLIENT_ID=your_search_client_id
NAVER_SEARCH_CLIENT_SECRET=your_search_client_secret

# ë„¤ì´ë²„ í´ë¼ìš°ë“œ (ìœ ë£Œ)
NCLOUD_ACCESS_KEY=your_access_key
NCLOUD_SECRET_KEY=your_secret_key
NCLOUD_SENS_SERVICE_ID=your_sens_service_id
NCLOUD_FROM_EMAIL=noreply@shipshare.com
NCLOUD_CLOVA_OCR_URL=your_ocr_url
NCLOUD_CLOVA_OCR_SECRET=your_ocr_secret
```

---

## ğŸš€ ì‹œì‘ ê°€ì´ë“œ

### Step 1: ë„¤ì´ë²„ ê°œë°œì ì„¼í„° ë“±ë¡
1. https://developers.naver.com ì ‘ì†
2. ë¡œê·¸ì¸ ë° ì• í”Œë¦¬ì¼€ì´ì…˜ ë“±ë¡
3. ì§€ë„ API, íŒŒíŒŒê³  API, ê²€ìƒ‰ API í™œì„±í™”
4. Client ID, Secret ë°œê¸‰

### Step 2: ë„¤ì´ë²„ í´ë¼ìš°ë“œ ê³„ì • (ì„ íƒ)
1. https://console.ncloud.com ì ‘ì†
2. SENS, CLOVA OCR ì„œë¹„ìŠ¤ ì‹ ì²­
3. API Key ë°œê¸‰

### Step 3: í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
```bash
# .dev.vars íŒŒì¼ ìƒì„±
cp .dev.vars.example .dev.vars
# API í‚¤ ì…ë ¥
```

### Step 4: ë¼ì´ë¸ŒëŸ¬ë¦¬ ìƒì„± (ì œê°€ í•´ë“œë¦´ê²Œìš”!)
```bash
src/lib/naver-maps.ts
src/lib/naver-papago.ts
src/lib/naver-search.ts
src/lib/ncloud-ocr.ts
```

---

## âœ… ë‹¤ìŒ ë‹¨ê³„

ì§€ê¸ˆ ë°”ë¡œ êµ¬í˜„ì„ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?

1. **ë„¤ì´ë²„ ì§€ë„ API ì—°ë™** (ë¬´ë£Œ, ìµœìš°ì„ )
2. **íŒŒíŒŒê³  ë²ˆì—­ API ì—°ë™** (ë¬´ë£Œ, ë‹¤êµ­ì–´)
3. **CLOVA OCR ì—°ë™** (ìœ ë£Œ, ì„ í•˜ì¦ê¶Œ ìŠ¤ìº”)

ë§ì”€ë§Œ í•´ì£¼ì‹œë©´ ë°”ë¡œ ì½”ë“œ ìƒì„±í•˜ê³  GitHubì— í‘¸ì‹œí•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤! ğŸš€

---

**ì‘ì„±ì¼**: 2024-11-21  
**ì‘ì„±ì**: AI Assistant  
**ìƒíƒœ**: ì‹¤ì œ API ì—°ë™ ì¤€ë¹„ ì™„ë£Œ âœ…
